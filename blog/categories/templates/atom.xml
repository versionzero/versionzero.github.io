<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Templates | Pre-Released Ideas]]></title>
  <link href="http://versionzero.github.io/blog/categories/templates/atom.xml" rel="self"/>
  <link href="http://versionzero.github.io/"/>
  <updated>2015-01-11T23:06:20-08:00</updated>
  <id>http://versionzero.github.io/</id>
  <author>
    <name><![CDATA[Ben Burnett]]></name>
    <email><![CDATA[yeah@right.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using C++ Templates to Generate Compile-time Arrays]]></title>
    <link href="http://versionzero.github.io/blog/2013/02/17/using-c-plus-plus-templates-to-generate-compile-time-arrays/"/>
    <updated>2013-02-17T09:22:00-08:00</updated>
    <id>http://versionzero.github.io/blog/2013/02/17/using-c-plus-plus-templates-to-generate-compile-time-arrays</id>
    <content type="html"><![CDATA[<p>There was huge amount of attention payed to template meta-programming
in C++ within recent history.  The idea was to let the compiler do
some additional work upfront so that the runtime environment would be
then forever relived of the need to fill the same role.</p>

<!--more-->


<p>The goto example in Computer Science for recursion is to list the
first <em>n</em> <a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci</a>
numbers. It&rsquo;s easy to see why this is done, the code is very simple
and highly readable:</p>

<p><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div></p>

<p>Of course, we would never actually do this in practice&ndash;since it
inefficient&ndash;but it does nicely illustrate the beauty of simplicity of
recursion.  It&rsquo;s fitting then, that we try using the same example to
use the same function to illustrate compile-time array generation.</p>

<p>Note that <code>gcc</code>/<code>clang</code> users will not be able to take advantage of
this, as it seems to only be a &ldquo;feature&rdquo; of the Microsoft C++
compiler.  It&rsquo;s also non-standard, so it&rsquo;s unlikely to work at any
point in the future.</p>

<p><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">fibonacci_numbers</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">T</span> <span class="n">end</span> <span class="o">=</span> <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">end</span>
        <span class="o">+</span> <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">&gt;::</span><span class="n">end</span><span class="p">;</span>
<span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">static</span> <span class="k">const</span> <span class="n">T</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">static</span> <span class="k">const</span> <span class="n">T</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">T</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">static</span> <span class="k">const</span> <span class="n">T</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span></code></pre></div></p>

<p>The code uses a few tricks to accomplish it&rsquo;s job: We use partial
specialization to help define the base case of the recursion.  This
can be seen in the last three lines, where the numbers listed
coincide with the conditions in the original code.</p>

<p>The more surprising property we take advantage of is that the MS C++
compiler allocates storage in the stack for the <code>end</code> member of
<code>fibonacci_numbers</code>.  Thus, since we are recursively defining
instances of the <code>fibonacci_numbers</code> structure, the compiler allocates
stack storage for each definition.</p>

<p>Once compiled, accessing the data must be done in reverse, due to the
nature of the template recursion.  The following loop prints the first
12 Fibonacci numbers:</p>

<p><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span>
<span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span> <span class="n">fibonacci</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&amp;</span><span class="n">ndash</span><span class="p">;)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">fibonacci</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">)).</span><span class="n">end</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div></p>

<p>It&rsquo;s not pretty, but it is effective.  It should be easy to write an
iterator wrapper for the above code, but I&rsquo;ll leave that for a future
post or update.</p>
]]></content>
  </entry>
  
</feed>
