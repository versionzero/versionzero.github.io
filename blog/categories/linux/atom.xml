<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Pre-Released Ideas]]></title>
  <link href="http://versionzero.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://versionzero.github.io/"/>
  <updated>2015-01-12T16:16:14-08:00</updated>
  <id>http://versionzero.github.io/</id>
  <author>
    <name><![CDATA[Ben Burnett]]></name>
    <email><![CDATA[yeah@right.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Revisiting the Car Computer]]></title>
    <link href="http://versionzero.github.io/blog/2015/01/12/new-gps-and-obd2-car-toy/"/>
    <updated>2015-01-12T16:15:00-08:00</updated>
    <id>http://versionzero.github.io/blog/2015/01/12/new-gps-and-obd2-car-toy</id>
    <content type="html"><![CDATA[<h1></h1>

<p>In a previous post, I started ruminating on the prospect of outfitting
my (then) new car with a GPS and On-Board-Diagnostic II (herein ODB2)
logger machine.</p>

<p>At the time, I didn&rsquo;t know much about GPS, ODB2, or even cars, for
that matter.  It&rsquo;s now ten months later, and I still know very little
about them, except I did learn enough to change the way I first
approached the design of the logger machine.</p>

<p>My first mistake, though you could not have convinced me of it at the
time, was to not do an extensive survey of all GPS and ODB2 software
packages for Linux.  Instead, having looked at only a handful, I
picked a few packages that, while effective, were hard to use,
troubleshoot and maintain.  (This is not entirely true, it was mostly
the ODB2 packages that left much to be desired.)  Ten months has shown
me that a few more weeks of searching would have saved me 7-8 months
of frustration.</p>

<p>But that&rsquo;s neither here nor there&ndash;so we won&rsquo;t dwell on it. Well, not
too much.</p>

<p>I recently had a few weeks leave from my day job(s?), and the part of
the intractable boredom of being free of any responsibility to
anything or anyone, revitalized my interest in this so called logger
machine.</p>

<p>The first thing I did was to take a much closer look at the available
tools and put more effort into choosing the appropriate ones from the
start. I&rsquo;m happy to say that the extra effort was not exerted in vain.
I found a single tool (package?) that performs all the required
functions.</p>

<p>To be brief on the subject of research, I ran across an almost
tailor-made-for-use-case project named, appropriately enough, &ldquo;OBD GPS
Logger&rdquo; or obdgpslogger for short(er).  I am not sure how I missed it
the first time through&hellip; I may have seen the screenshots of some of
its tools and figured it was all graphically driven.  Anyway, what it
does, simply, is periodically gather OBD data, GPS location data and a
time-stamp.  With this information, it is a simple matter to examine
where and when particular events in a vehicle take effect.  More
interestingly, the data may help inform my future driving, by allowing
me to identify weak points in my habits.  Whether or not I&rsquo;ll change
my driving habits is an entirely different discussion.</p>

<p>The obdgpslogger package was almost perfectly tailored to my use case.
Unfortunately, because of architectural changes in its dependencies,
it would not compile.  There were three possible solutions to this:
(1) return to not bothering with the project, (2) remove all the
pre-packaged and installed dependencies and install ones compatible
with the available version of obdgpslogger, or (3) update the
obdgpslogger code-base to support the new API exposed by its
dependencies.</p>

<p>At this point, (1) wasn&rsquo;t really a consideration, since I&rsquo;d just begun
working on the project, and still retained some interest in its
completion.  Of course (2) would be a reasonable compromise between
having a functioning prototype and an out-of-date set of dependencies
that may break other software packages, contain bugs that have only
recently been addressed, and so on.  Still, it would have been a
working solution, so I did not dismiss it entirely.  That is, not
until I found that (3) only required a few trivial changes.  This
established (3) as my approach; though the approach was also slightly
coloured by my desire to write new code, even if it was just a few
lines.</p>

<p>With that decision made, it was a simple matter getting the original
code, creating a public fork, and addressing every compilation error
as they occurred.</p>

<p><a href="http://en.wikipedia.org/wiki/Table_of_OBD-II_Codes">http://en.wikipedia.org/wiki/Table_of_OBD-II_Codes</a>
<a href="http://planbperformance.net/dan/blog/?p=379">http://planbperformance.net/dan/blog/?p=379</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Towards a Working Raspberry Pi In-car Computer]]></title>
    <link href="http://versionzero.github.io/blog/2013/02/24/towards-a-working-rpi-in-car-computer/"/>
    <updated>2013-02-24T19:52:00-08:00</updated>
    <id>http://versionzero.github.io/blog/2013/02/24/towards-a-working-rpi-in-car-computer</id>
    <content type="html"><![CDATA[<p>Ever since I purchased my latest vehicle, I&rsquo;ve been working on a
little side project to interface directly with the vehicle&rsquo;s on-board
computer.</p>

<p>The task itself is pretty straight forward: buy device capable of
plugging in to the vehicle&rsquo;s ODB2 port, and run some free or
inexpensive Android app to gather the information.</p>

<p>Unfortunately, the above process requires a great deal of user
intervention.  First, you must always plug and unplug the ODB2 device.
Second, you must either have an Android device on your person or in
the vehicle capable of running the required software or a computer
with a variety of command-line tools installed.  The latter is
impractical, and the former is error prone (I&rsquo;ll forget to start the
app, take the readings, etc.) and tedious (The data must later be
extracted from the app manually, or a web-service must be made
available to push the data to&ndash; which also requires a data plan, if
the car is not always in the proximity of a wifi access point).</p>

<p>Raspberry Pi to the rescue.</p>

<!--more-->


<p>The <a href="http://www.raspberrypi.org">Raspberry Pi</a> is a small, inexpensive
low-power computing machine.  It was originally developed with
teaching in mind, but sparked an enormous hobby market.  The Raspberry
Pi, or raspi for short, is available in two models: Model A is $25 the
Model B is $35. The differences between the models is nominal: the
more expensive one has more USB ports, more RAM and an Ethernet port.
As a developer, the Model B is preferable, since it provides easy
extension through USB and trivial network access via ethernet, not to
mention more room to write sloppier prototype code in the roomy 512MB
main memory.  The Model A would be best suited to production or
permanent projects, post development.  (Not true in all cases: having
network access can be critical for some applications&ndash; though a USB
wireless dongle may mediate this issue.)</p>

<p>I purchased two of the $35 Model Bs, for a separate project, but
quickly found that they would be a good fit for a variety of computing
projects.  One of these projects ended up being the computer for my
vehicle.</p>

<p>The original intention of car computer was to keep track of details
that were important to me, but slightly time consuming and tedious.
One simple motivating example was tracking fuel economy.  It&rsquo;s a
simple calculation to make, record and compare to previous trips.  But
why bother doing this work by hand if it will eventually end up in a
computer, if the computer itself can gather and tabulate the data
automatically.  It&rsquo;s hardly an earth shattering improvement, but led
to further ideas.  For instance: it would be great to know <em>where</em>,
<em>when</em> and <em>why</em> the vehicle experiences the worst fuel economy.  By
taking additional data samples, like location, speed, temperature,
time, and a variety of engine performance metrics, a very clear
picture of how a vehicle performs will emerge.</p>

<p>Towards these ends, I&rsquo;ve been configuring a raspi to read from a
Bluetooth ODB2 adapter and stash the information until it can be
transferred to my home network for processing.</p>

<p>The idea is simple: poll the ODB2 adapter periodically for all data it
can return.  Simultaneously poll a GPS unit and stash the correlated
data locally on the raspi device.  If and when my home network is
within range, join the wireless network and transfer the collected
data for processing.</p>

<p><em>more on the way</em></p>

<h2>Configuration</h2>

<h3>USB Hub Configuration</h3>

<p>The first problem I ran in to was that the cheap USB Bluetooth dongle
I purchased was not well received by my raspi.  Fortunately, like many
things, I was not the only one who had this issue.  A quick web-search
away turned up the <a href="http://raspberrypi.stackexchange.com/questions/1886/what-kernel-parameters-are-available-for-fixing-usb-problems">solution</a>:
the USB hub&rsquo;s speed had to be turned down to the USB 1.1 standard, as
the 2.0 standard was known to no play well with some cheap devices.</p>

<p>The fix was simple, once I found it, and only involved changing a few
boot variables the kernel uses to initialize hardware on boot.  In
particular, I changed:</p>

<ul>
<li><code>dwc_otg.speed</code>: 1 will limit USB speed to full speed 12Mbps (USB 1.1).</li>
<li><code>dwc_otg.microframe_schedule</code>: 1 (default now) This should fix the
error when too many periodic endpoints are present.</li>
</ul>


<h3>Bluetooth Configuration</h3>

<p>Having no documentation on the ODB2 sensor I purchased, I used the
<code>sdptool</code> to tell me a little about the device.</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo sdptool records 00:19:5D:27:12:6E
<span class="p">&amp;</span>hellip<span class="p">;</span>
Service Name: SPP Dev
Service RecHandle: 0x10002
Service Class ID List:
  <span class="p">&amp;</span>ldquo<span class="p">;</span>Serial Port<span class="p">&amp;</span>rdquo<span class="p">;</span> <span class="o">(</span>0x1101<span class="o">)</span>
Protocol Descriptor List:
  <span class="p">&amp;</span>ldquo<span class="p">;</span>L2CAP<span class="p">&amp;</span>rdquo<span class="p">;</span> <span class="o">(</span>0x0100<span class="o">)</span>
  <span class="p">&amp;</span>ldquo<span class="p">;</span>RFCOMM<span class="p">&amp;</span>rdquo<span class="p">;</span> <span class="o">(</span>0x0003<span class="o">)</span>
    Channel: 1
Language Base Attr List:
  code_ISO639: 0x656e
  encoding:    0x6a
  base_offset: 0x100</code></pre></div></p>

<p>It&rsquo;s not a hugely informative dump of information&mdash;in fact it&rsquo;s
downright cryptic&mdash;but it does provide us with the protocol and
channel to connect with.</p>

<p>By configuring <code>/etc/bluetooth/rfcomm.conf</code> correctly, we get a device
<code>/dev/rfcomm0</code>.</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash">rfcomm0 <span class="o">{</span>
  <span class="nb">bind </span>yes<span class="p">;</span>
  device 00:0D:3F:45:DF:8A<span class="p">;</span>
  channel 1<span class="p">;</span>
  comment <span class="p">&amp;</span>ldquo<span class="p">;</span>ODB2 Sensor<span class="p">&amp;</span>rdquo<span class="p">;;</span>
<span class="o">}</span></code></pre></div></p>

<p>Then we only need to restart the bluetooth service:</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo systemctl stop  bluetooth.service <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> <span class="se">\</span>
  sudo systemctl start bluetooth.service</code></pre></div></p>

<p>Eventually one could use the command:</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo rfcomm <span class="nb">bind </span><span class="m">0</span> 00:15:A0:7A:90:F2 1</code></pre></div></p>

<p>Where the 0 is the device suffix, the hardware address is that of the
ODB2 sensor and the 1 is the channel we want to connect on.  We should
now see the RFCOMM device available for use:</p>

<p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>ls -l /dev/rfcomm0
crw-rw<span class="p">&amp;</span>mdash<span class="p">;</span>- <span class="m">1</span> root uucp 216, <span class="m">0</span> Jan  <span class="m">1</span> 01:14 /dev/rfcomm0</code></pre></div></p>
]]></content>
  </entry>
  
</feed>
