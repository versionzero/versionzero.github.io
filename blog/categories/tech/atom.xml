<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | Pre-Released Ideas]]></title>
  <link href="http://versionzero.github.io/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://versionzero.github.io/"/>
  <updated>2015-01-12T16:16:14-08:00</updated>
  <id>http://versionzero.github.io/</id>
  <author>
    <name><![CDATA[Ben Burnett]]></name>
    <email><![CDATA[yeah@right.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Revisiting the Car Computer]]></title>
    <link href="http://versionzero.github.io/blog/2015/01/12/new-gps-and-obd2-car-toy/"/>
    <updated>2015-01-12T16:15:00-08:00</updated>
    <id>http://versionzero.github.io/blog/2015/01/12/new-gps-and-obd2-car-toy</id>
    <content type="html"><![CDATA[<h1></h1>

<p>In a previous post, I started ruminating on the prospect of outfitting
my (then) new car with a GPS and On-Board-Diagnostic II (herein ODB2)
logger machine.</p>

<p>At the time, I didn&rsquo;t know much about GPS, ODB2, or even cars, for
that matter.  It&rsquo;s now ten months later, and I still know very little
about them, except I did learn enough to change the way I first
approached the design of the logger machine.</p>

<p>My first mistake, though you could not have convinced me of it at the
time, was to not do an extensive survey of all GPS and ODB2 software
packages for Linux.  Instead, having looked at only a handful, I
picked a few packages that, while effective, were hard to use,
troubleshoot and maintain.  (This is not entirely true, it was mostly
the ODB2 packages that left much to be desired.)  Ten months has shown
me that a few more weeks of searching would have saved me 7-8 months
of frustration.</p>

<p>But that&rsquo;s neither here nor there&ndash;so we won&rsquo;t dwell on it. Well, not
too much.</p>

<p>I recently had a few weeks leave from my day job(s?), and the part of
the intractable boredom of being free of any responsibility to
anything or anyone, revitalized my interest in this so called logger
machine.</p>

<p>The first thing I did was to take a much closer look at the available
tools and put more effort into choosing the appropriate ones from the
start. I&rsquo;m happy to say that the extra effort was not exerted in vain.
I found a single tool (package?) that performs all the required
functions.</p>

<p>To be brief on the subject of research, I ran across an almost
tailor-made-for-use-case project named, appropriately enough, &ldquo;OBD GPS
Logger&rdquo; or obdgpslogger for short(er).  I am not sure how I missed it
the first time through&hellip; I may have seen the screenshots of some of
its tools and figured it was all graphically driven.  Anyway, what it
does, simply, is periodically gather OBD data, GPS location data and a
time-stamp.  With this information, it is a simple matter to examine
where and when particular events in a vehicle take effect.  More
interestingly, the data may help inform my future driving, by allowing
me to identify weak points in my habits.  Whether or not I&rsquo;ll change
my driving habits is an entirely different discussion.</p>

<p>The obdgpslogger package was almost perfectly tailored to my use case.
Unfortunately, because of architectural changes in its dependencies,
it would not compile.  There were three possible solutions to this:
(1) return to not bothering with the project, (2) remove all the
pre-packaged and installed dependencies and install ones compatible
with the available version of obdgpslogger, or (3) update the
obdgpslogger code-base to support the new API exposed by its
dependencies.</p>

<p>At this point, (1) wasn&rsquo;t really a consideration, since I&rsquo;d just begun
working on the project, and still retained some interest in its
completion.  Of course (2) would be a reasonable compromise between
having a functioning prototype and an out-of-date set of dependencies
that may break other software packages, contain bugs that have only
recently been addressed, and so on.  Still, it would have been a
working solution, so I did not dismiss it entirely.  That is, not
until I found that (3) only required a few trivial changes.  This
established (3) as my approach; though the approach was also slightly
coloured by my desire to write new code, even if it was just a few
lines.</p>

<p>With that decision made, it was a simple matter getting the original
code, creating a public fork, and addressing every compilation error
as they occurred.</p>

<p><a href="http://en.wikipedia.org/wiki/Table_of_OBD-II_Codes">http://en.wikipedia.org/wiki/Table_of_OBD-II_Codes</a>
<a href="http://planbperformance.net/dan/blog/?p=379">http://planbperformance.net/dan/blog/?p=379</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Revision Control Is Not Just a Backup Tool]]></title>
    <link href="http://versionzero.github.io/blog/2015/01/12/revision-control-is-not-a-backup-tool/"/>
    <updated>2015-01-12T13:04:00-08:00</updated>
    <id>http://versionzero.github.io/blog/2015/01/12/revision-control-is-not-a-backup-tool</id>
    <content type="html"><![CDATA[<p>I made the mistake, when I started using revision control&mdash;like many
others might have done&mdash;to think of it, conceptually, as a backup
mechanism. This, it turns out, I believe, is naive, and a very poor
characterization of the power of revision control. Let me explain.</p>

<!--more-->


<p>First things first: starting an opinion piece by contradicting
yourself is a gamble, but I hope you&rsquo;ll still hear me out.  And notice
I do call this an opinion: I&rsquo;ve run across to many blog posts that
make bold statements of fact, but provide little more than anecdotal
evidence to support their claim.  There very well may be evidence for
what I am about to say, but I have not done any background work on the
topic. (I will amend this article as my understanding of the tools
improves.)</p>

<p>So what&rsquo;s the contradiction? Well, revision control tools actualy are
backup tools: i.e. they obviously provide a way to recover old data.
Moreover, there are backup and synchronization tools that use revision
control under the hood.  But these uses only encompass a small subset
of the power of revision control.  In what follows, we shall endeavour
to present some of the important distinctions between revision control
and backup tools.</p>

<h2>What is Revision Control?</h2>

<p>We have all invented or borrowed a (possibly naive) system for
revisions to electronic documents.  In some cases, these revisions can
be seen as dated copies of a file:</p>

<ul>
<li>CV-2010-09-12.doc;</li>
<li>CV-2012-04-09.doc;</li>
<li>etc.</li>
</ul>


<p>The intent, presumably, is to keep a history of the changes in the
content as well as preserving any content removed in subsequent
revisions.  This type of revision is practical for a small number of
documents with fairly stable content: a curriculum vitae may change
infrequently enough that there may only ever be a few revisions.
Source code is another story.</p>

<p>Source code revisions are useful for the same reasons CV revisions
are.  Revisions for code are even more useful when there are
(possibly) many people working over a long period of time on a
project.  We will imagine this time period to be 20 years.  This
length of time can almost ensure that there will exist code that was
originally written by one person and subsequently updated by
others. This is where revisions come in to play.</p>

<p>Comments are one thing, they tell the reader what the code is supposed
to do and why it was decided that it should be done that way&ndash;for
better or worse.  Comments are discussions about code in a highly
localized environment.  Documentation can be used to provide the
more general purpose of the program, but there is still information
missing.  A revision control system allows changes in code to be
tracked but also explained in a different forum than would be
appropriate for comments.  It&rsquo;s easy to imagine a body of code that is
20 years old will have files and sub-systems that have changes a dozen
or so times.  Keeping a record of all the comments from previous code
that is no longer relevant to current code is a bad idea&ndash;it can
confuse the intent of the code.  Instead, the changes can be cataloged
as part of a revision; that is, they will still describe the code
present in the old versions, but do not need to be preserved in new
versions.  Furthermore, the revision comments can include a discussion
on the nature of the changes.  In many cases this information is
interesting and worth preserving, but is generally not useful to have
at the code or documentation level: the fidelity of the content is too
distinct from those.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Karabiner private.xml]]></title>
    <link href="http://versionzero.github.io/blog/2015/01/11/karabiner-private-xml/"/>
    <updated>2015-01-11T08:41:00-08:00</updated>
    <id>http://versionzero.github.io/blog/2015/01/11/karabiner-private-xml</id>
    <content type="html"><![CDATA[<p>Over the years, through school and other areas, I became addicted to
both Emacs and my Mac. Unfortunately, as both evolved, they became less
and less friendly with each other.</p>

<!--more-->


<p>One thing in particular bothers me about the interaction between Emacs
and a Mac: the keyboard. It used to be I could use Ctrl+Left/Right
arrow to skip an Emacs defined &ldquo;word&rdquo;; however, this became the way
for Mac users to switch spaces. This is when I found Karabiner. I now
use Karabiner to change the purpose of the Fn key so that I can use it
and the arrow keys to switch spaces, but also maintain the ability to
skip around in Emacs by words, instead of simply by character or
paragraph.</p>

<p>Here is my private.xml for this particular use case:</p>

<p><div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="ni">&amp;lt;</span>?xml version=<span class="ni">&amp;ldquo;</span>1.0<span class="ni">&amp;rdquo;</span>?&gt;
<span class="nt">&lt;root&gt;</span>
    <span class="nt">&lt;item&gt;</span>
        <span class="nt">&lt;name&gt;</span>My Spaces (I like to use Fn+Left/Right arrow for switching spaces)<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;appendix&gt;</span>Change Fn to Ctrl+Option+Command<span class="nt">&lt;/appendix&gt;</span>
        <span class="nt">&lt;identifier&gt;</span>private.fn_control_option_command_hyper<span class="nt">&lt;/identifier&gt;</span>
        <span class="nt">&lt;autogen&gt;&lt;strong&gt;</span>KeyToKey<span class="nt">&lt;/strong&gt;</span> KeyCode::FN, KeyCode::COMMAND_L, ModifierFlag::OPTION_L, ModifierFlag::CONTROL_L<span class="nt">&lt;/autogen&gt;</span>
    <span class="nt">&lt;/item&gt;</span>
<span class="nt">&lt;/root&gt;</span></code></pre></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Streaming From iPhone to iPhone]]></title>
    <link href="http://versionzero.github.io/blog/2015/01/03/streaming-from-iphone-to-iphone/"/>
    <updated>2015-01-03T07:11:00-08:00</updated>
    <id>http://versionzero.github.io/blog/2015/01/03/streaming-from-iphone-to-iphone</id>
    <content type="html"><![CDATA[<p>Part of this project includes code, not just writing. Obviously, the
code to the site is available, but what follows is code that is
independent of the site, in so far as it doesn&rsquo;t help run it. The code
itself is hosted on another GitHub account, for my own reasons, but
the writeups will all be here.</p>

<!--more-->


<h3>Streaming to iOS Devices</h3>

<p>The first question that comes to mind is why? Why would you want to
stream to an iOS device rather than just from it?</p>

<p>The answer reveals how fortunate (spoiled) I&rsquo;ve been over the past few
years: I&rsquo;ve always been a technology enthusiast and I have always been
one to try to keep somewhat up-to-date on the latest gadgets. In some
respects, this has meloed over the years, but it hasn&rsquo;t stopped me
from buying a new previous generation iPhone every time a new one is
released. In this case, it means I am currently an owner of a 5s and
4s, as I have not gotten rid of the 4s yet. This is all relevant
because it lead me to this question: what can I do with an old iPhone
that I might not be able to do with a computer. It turns out, there is
a lot you can use an old iPhone for, much of which is not relevant,
except streaming.</p>

<p>I used my iPhone 4s as a remote and as a Netflix source to stream to
my TVs. The novelty of this quickly wore off, so I started looking
around for other uses. This is when I realized I&rsquo;d like to install it
in my car and stream to it, from another source. I have an iOS dock in
my car. Not one that connects to an existing stereo or cables, but is
instead a stereo designed to hold an iOS device internally (or a USB
drive, etc.). The idea for device reuse or specialized use would be to
allow to stream from one device to another. In my case, one iPhone to
another. This way, the music, etc. is on one device, but the output is
on another. This would make updating music and listening to it on the
car iPhone trivial, as the device would never need to have updated
manually, or if it did, it wouldn&rsquo;t be critical that be sync&rsquo;d every
night or even week. (Yes, a &ldquo;first world problem&rdquo; (FWP), but hey, most
technology fixes FWP these days&mdash;doesn&rsquo;t it? Not many Pinterest users
bragging about the bag of support rice they had dropped on their
head. Or maybe there are.)</p>

<h3>How to Stream</h3>

<p>Since we are writing an open source project, we can use a bunch of
open source libraries and tools. For the base streaming part, I&rsquo;ve
chosen to use <a href="https://github.com/abrasive/shairport">shairport</a>;
unfortunately, it does not support iOS out of the box, so we need to
make some modifications&mdash;which is actually a good thing: otherwise,
we&rsquo;d be done with the writing, right about now.</p>

<p><em>In progress</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ethical Computing]]></title>
    <link href="http://versionzero.github.io/blog/2014/12/27/ethical-computing/"/>
    <updated>2014-12-27T22:21:02-08:00</updated>
    <id>http://versionzero.github.io/blog/2014/12/27/ethical-computing</id>
    <content type="html"><![CDATA[<p>This essay is about performing and consuming computational cycles
ethically. Ethical computing is a means of computing with a focus on
reducing harmful externalities. We shall explore what an ethical
computation could look like from a variety of angles. We then argue
for a variety of means by which we might enable further development in
those areas.</p>

<!--more-->


<h2>Ethical Computation</h2>

<p>We shall explore each of the following topics in turn:</p>

<ol>
<li>The source of labor for the construction of physical computers</li>
<li>Sources of materials used in the construction of computer hardware</li>
<li>Sources of power used for the creation of computing cycles
(i.e. running the computer hardware)</li>
<li>Consumer, academic, industrial, and business influences on the
in-expense of computing products</li>
</ol>


<p>Later. we shall discus some possible solutions and , including:</p>

<ol>
<li>Frugal computing: the re-purposing of old computer hardware to
offset the costs associated with the disposal as well as powering
the hardware.</li>
</ol>


<p>We will focus on <em>popular</em> account of this issue, rather than a
densely inassesible accademic treatment. Not that we believe this will
lessen the power of the argument; we hope, instead, to make it more
readable and multimedia sourced. Using news articles and video sources
from TEDx, etc. we hope to broaden the audience and impact for this
topic. We believe this more important than the strict rigor of
academia&hellip; for the time being.</p>

<h2>Sources of Labor</h2>

<p>We begin with the human means of production. The party-line tells us
sweatshops are bad, immoral, unethical, torturous, etc.. The opposite
has been argued by
<a href="https://www.ted.com/talks/leslie_t_chang_the_voices_of_china_s_workers?language=en">Leslie T. Chang</a>:
According to Chang, the sweatshops can enable upward social,
economic. and educational movement&mdash;even if not in every instance. In
other words, the jobs create a more educated and highly skilled
workforce, and open up new possitions for further future workforce
accention. Clearly, this is not the whole picture: not all workers get
out, not all places are good or even comprehendible places to work;
however, that there exists exceptions is hopeful. It means there are
examples for new companies to sustain cheap labour, without
nessesarily being compromizingly opressive and exploitative&mdash;though
they still might be considered these things, by &ldquo;western&rdquo; standards.</p>

<p><em>In progress</em></p>
]]></content>
  </entry>
  
</feed>
