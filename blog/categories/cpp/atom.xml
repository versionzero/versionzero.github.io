<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cpp | Pre-Released Ideas]]></title>
  <link href="http://versionzero.github.io/blog/categories/cpp/atom.xml" rel="self"/>
  <link href="http://versionzero.github.io/"/>
  <updated>2015-01-12T07:26:39-08:00</updated>
  <id>http://versionzero.github.io/</id>
  <author>
    <name><![CDATA[Ben Burnett]]></name>
    <email><![CDATA[yeah@right.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mac OS Gets Cilk++ Support via Clang and LLVM]]></title>
    <link href="http://versionzero.github.io/blog/2013/03/24/mac-os-gets-cilk-plus-plus-support-via-clang-and-llvm/"/>
    <updated>2013-03-24T17:35:00-07:00</updated>
    <id>http://versionzero.github.io/blog/2013/03/24/mac-os-gets-cilk-plus-plus-support-via-clang-and-llvm</id>
    <content type="html"><![CDATA[<p>Part of my yet un-finished graduate work involved using a combination
of threading and cache-oblivious algorithms to improve the performance
of various linear algebra computations on sparse data sets.  During
the course of my work, I used a few concurrency models, including
Intel&rsquo;s <a href="http://cilkplus.org">Cilk Plus</a> data and task parallelism
techniques.</p>

<p>Recently, the <a href="http://cilkplus.github.com">Cilk Plus language extensions were introduced to the Clang frontend for LLVM</a>.  Which mean it
was available on Darwin.  Though the <a href="http://gcc.gnu.org/svn/gcc/branches/cilkplus/">Cilk Plus extensions and runtime have been available in GCC</a> for some time,
building the GCC code on Darwin proved to be non-trivial. (For me, at
least&mdash; the Linux build was far easier.)  The introduction of Cilk
Plus in Clang allows for easy compilation and use on the Darwin
platform.</p>

<!--more-->


<p>I used the instructions given on the new <a href="http://cilkplus.github.com">Cilk Plus/LLVM GitHub site</a>
to try a copy of the compiler on my local machine.</p>

<p>The current implementation only provides support for a subset of the
Cilk Plus language extensions: <code>cilk_spawn</code>, <code>cilk_sync</code>, and
<code>hyperobjects</code>.  Leaving features like <code>cilk_for</code>, array notation and
SIMD work for future releases.  Despite the not providing a full
feature-set, the Cilk Plus/LLVM tools can already be used to make
non-trivial parallel programs.</p>

<p>I dusted off some benchmarking code I used for previous experiments
and gave it a go on my laptop.  While not a high-performance big-steel
machine, my laptop does weigh in well with 16GB of RAM and a quad-core
Intel i7.</p>

<p>The code I ran uses a well-known matrix multiplication algorithm&mdash;
<a href="http://en.wikipedia.org/wiki/Strassen_algorithm">Strassen&rsquo;s algorithm</a>&mdash;to
create large parallel workloads.  The code was based on example code
shipped with the original 1996 <a href="http://supertech.csail.mit.edu/cilk/">MIT Cilk language and runtime</a>.  I modified the code
slightly to include the new language extensions as well as to provide
slightly more performance information. (I&rsquo;ll post the changes
shortly.)</p>

<p>I ran the code through a variety of benchmarks, which I&rsquo;ve included
bellow.</p>

<p><img src="/images/speed-up.png" title="Speedup of Strassen's Algorithm with
 Cilk Plus/LLVM" alt="speedup" /></p>

<p>The legend labels describe the size of the matrices being used.  For
instance, 1024 mean that Strassen&rsquo;s Algorithm is being run using
inputs of size 1024 by 1024.  Notice we don&rsquo;t achieve linear
<a href="http://en.wikipedia.org/wiki/Speedup">speedup</a>, but we do get very
close.  I think with a little extra fine tuning (1) and the explicit
use of some SIMD instructions, near-linear speedup could be
achieved. If you want the data, you can get it
<a href="/files/llvmcilk-results.xlsx">here</a>.</p>

<ol>
<li>Yes, I know: cache oblivious algorithms aren&rsquo;t <em>supposed</em> to
require tuning.  In practice, unfortunately, they do.  Maybe not as
much tuning as their cache aware brethren, but still the require some.
Even the original MIT code had some tuning code in it, so I&rsquo;m not
alone in thinking it necessary.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using C++ Templates to Generate Compile-time Arrays]]></title>
    <link href="http://versionzero.github.io/blog/2013/02/17/using-c-plus-plus-templates-to-generate-compile-time-arrays/"/>
    <updated>2013-02-17T09:22:00-08:00</updated>
    <id>http://versionzero.github.io/blog/2013/02/17/using-c-plus-plus-templates-to-generate-compile-time-arrays</id>
    <content type="html"><![CDATA[<p>There was huge amount of attention payed to template meta-programming
in C++ within recent history.  The idea was to let the compiler do
some additional work upfront so that the runtime environment would be
then forever relived of the need to fill the same role.</p>

<!--more-->


<p>The goto example in Computer Science for recursion is to list the
first <em>n</em> <a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci</a>
numbers. It&rsquo;s easy to see why this is done, the code is very simple
and highly readable:</p>

<p><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div></p>

<p>Of course, we would never actually do this in practice&ndash;since it
inefficient&ndash;but it does nicely illustrate the beauty of simplicity of
recursion.  It&rsquo;s fitting then, that we try using the same example to
use the same function to illustrate compile-time array generation.</p>

<p>Note that <code>gcc</code>/<code>clang</code> users will not be able to take advantage of
this, as it seems to only be a &ldquo;feature&rdquo; of the Microsoft C++
compiler.  It&rsquo;s also non-standard, so it&rsquo;s unlikely to work at any
point in the future.</p>

<p><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">fibonacci_numbers</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">T</span> <span class="n">end</span> <span class="o">=</span> <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">end</span>
        <span class="o">+</span> <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">&gt;::</span><span class="n">end</span><span class="p">;</span>
<span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">static</span> <span class="k">const</span> <span class="n">T</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">static</span> <span class="k">const</span> <span class="n">T</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">T</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">static</span> <span class="k">const</span> <span class="n">T</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span></code></pre></div></p>

<p>The code uses a few tricks to accomplish it&rsquo;s job: We use partial
specialization to help define the base case of the recursion.  This
can be seen in the last three lines, where the numbers listed
coincide with the conditions in the original code.</p>

<p>The more surprising property we take advantage of is that the MS C++
compiler allocates storage in the stack for the <code>end</code> member of
<code>fibonacci_numbers</code>.  Thus, since we are recursively defining
instances of the <code>fibonacci_numbers</code> structure, the compiler allocates
stack storage for each definition.</p>

<p>Once compiled, accessing the data must be done in reverse, due to the
nature of the template recursion.  The following loop prints the first
12 Fibonacci numbers:</p>

<p><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span>
<span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="n">fibonacci_numbers</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span> <span class="n">fibonacci</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&amp;</span><span class="n">ndash</span><span class="p">;)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">fibonacci</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">)).</span><span class="n">end</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div></p>

<p>It&rsquo;s not pretty, but it is effective.  It should be easy to write an
iterator wrapper for the above code, but I&rsquo;ll leave that for a future
post or update.</p>
]]></content>
  </entry>
  
</feed>
