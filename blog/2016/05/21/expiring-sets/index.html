<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://versionzero.org/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://versionzero.org/theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://versionzero.org/theme/stylesheet/font-awesome.min.css">


    <link href="http://versionzero.org/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="versionzero Atom">



  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Ben Burnett" />
<meta name="description" content="Redis-driven sets expired by time." />
<meta name="keywords" content="Python, Redis, Data Structures">
<meta property="og:site_name" content="versionzero"/>
<meta property="og:title" content="Time Expired Sets Using Redis"/>
<meta property="og:description" content="Redis-driven sets expired by time."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://versionzero.org/blog/2016/05/21/expiring-sets/index.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2016-05-21 05:00:00-06:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://versionzero.org/author/ben-burnett.html">
<meta property="article:section" content="Programming"/>
<meta property="article:tag" content="Python"/>
<meta property="article:tag" content="Redis"/>
<meta property="article:tag" content="Data Structures"/>
<meta property="og:image" content="">
  <title>versionzero &ndash; Time Expired Sets Using Redis</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://versionzero.org">
        <img src="http://versionzero.org/theme/img/profile.png" alt="" title="">
      </a>
      <h1><a href="http://versionzero.org"></a></h1>
      <p></p>
      <nav>
        <ul class="list">
        </ul>
      </nav>
      <ul class="social">
      </ul>
    </div>
  </aside>
  <main>

<article>
  <header>
    <h1 id="expiring-sets">Time Expired Sets Using Redis</h1>
    <p>Posted on Sat 21 May 2016 in <a href="http://versionzero.org/category/programming.html">Programming</a></p>
  </header>
  <div>
    <p><a href="http://redis.io">Redis</a> is an open-source (or free software) server
for managing in-memory data structures. It provides native support for
a variety of data structures, including strings, lists, (sorted) sets,
etc. It can be used in a variety of situations, such as providing fast
look-ups in a cached environment.</p>
<p>While Redis supports timeouts for keys, given a time-to-live (TTL), it
does not provide support for timeouts on the values of a key. The
purpose of this article is to explore option that enable such
behavior.</p>
<p>There are a variety of ways in which we can extract this behavior
from Redis. We will focus on two such methods.</p>
<h2>List of keys</h2>
<p>First, we can use a list of key names and a set of keys that can be
expired, with the values attached to them.</p>
<p>Consider the following:</p>
<div class="highlight"><pre><span></span>LPUSH list &quot;key1&quot;
LPUSH list &quot;key2&quot; # list now contains &quot;key1&quot;,&quot;key2&quot;
...
SET key1 &quot;Hello,&quot;
EXPIRE key1 10
SET key2 &quot;World!&quot;
EXPIRE key2 10
...
</pre></div>


<p>Here we create at least two keys, one for the list of keys considered
and one for each value we want to store and eventually
expire. Consider <code>key1</code> as an example: it is referenced in <code>list</code> and
is given the value of <code>"Hello,"</code> with a TTL of <code>10</code>.</p>
<p>Notice this method requires additional book-keeping to remove keys
from <code>list</code> after they have expired. Detecting when a key has expired
can be done as follows:</p>
<div class="highlight"><pre><span></span>TTL key1
</pre></div>


<p>Before <code>key1</code> has expired, the <code>TTL</code> command will return the TTL it
was originally assigned. When <code>key1</code> has expired, the <code>TTL</code> command
will return <code>-1</code>. Iterating over <code>list</code> and executing <code>TTL</code> on the
values results in a new list with only the values that have not yet
expired.</p>
<p>The complexity for the book-keeping in this implementation is <em>O(N)</em>,
where <em>N</em> is the number of elements in <code>list</code>.</p>
<h2>Sorted Set</h2>
<p>The second method uses a sorted set and is slightly more
complex. Recall that sorted sets contain a score and a value (possibly
the score itself). Our implementation uses a score and a single value
per entry.</p>
<p>Consider the following:</p>
<div class="highlight"><pre><span></span>ZADD sset 4 &quot;Hello,&quot;
ZADD sset 5 &quot;World!&quot;
ZADD sset 2 &quot;How&quot;
ZADD sset 1 &quot;are&quot;
ZADD sset 3 &quot;you?&quot;
...
ZRANGE sset 0 -1 WITHSCORES # returns all elements in sset
1) &quot;are&quot;
2) &quot;How&quot;
...
</pre></div>


<p>This creates a sorted set containing
<code>"are","How","you?","Hello,","World!"</code>, with their respective
scores. Notice the values are not in the same order in which they were
added.  This is due to the way <code>ZSET</code> and sorted sets, in general,
work. A sorted set stores its values by score, rather than insertion
order.</p>
<p>To expire elements in this implementation we perform the following:</p>
<div class="highlight"><pre><span></span>ZREMRANGEBYSCORE sset -inf 3
</pre></div>


<p>Where <code>-inf</code> is is the lowest possible score in the sorted set <code>sset</code>
and <code>3</code> asks for the removal of every element with a score of <code>3</code> or
less.</p>
<p>Notice that, again, we need additional book-keeping to remove keys
from <code>sset</code> that have expired. Book-keeping in this instance requires
<em>O((log N)+M)</em>, where <em>N</em> is the number of elements in <code>sset</code> and <em>M</em>
is the number elements being expired. Also note that this style of
book-keeping requires substantially less logic work than the one
required by the list implementation.</p>
<h2>An Example</h2>
<p>So why is all of this useful?</p>
<p>Consider the case where you want to expire a set of values after a
certain amount of time has past. This might be useful when caching a
data-set that becomes less and less interesting over time. For
example, we might want to know the state of server over last
hour. This might include the load average or the average number of
page faults.</p>
<p>We need a number of data points for this to work: a timestamp of when
the measurement was taken and the values seen at that point in time.</p>
<p>Consider the following:</p>
<div class="highlight"><pre><span></span>ZADD srvstats 1463879868 &quot;{load:1.05,faults:1}&quot;
ZADD srvstats 1463880018 &quot;{load:1.05,faults:4}&quot;
ZADD srvstats 1463880168 &quot;{load:1.15,faults:3}&quot;
ZADD srvstats 1463880318 &quot;{load:1.14,faults:2}&quot;
ZADD srvstats 1463880468 &quot;{load:1.06,faults:5}&quot;
...
</pre></div>


<p>Where <code>1463879868</code> is a timestamp for the measurement and <code>load</code> and
<code>faults</code> are the data points we are interested in.</p>
<p>Imagine we want to expire values after two minutes. This requires a
trivial calculation: let <strong>TTL</strong> be 120 (two minutes in seconds) and
<strong>now</strong> be <code>1463880468</code>. Furthermore, let <strong>upper</strong> be <strong>(now -
TTL)</strong>, or <code>1463880339</code>. To expire those values older than two
minutes, we perform the following operation:</p>
<div class="highlight"><pre><span></span>ZREMRANGEBYSCORE sset -inf 1463880339
</pre></div>


<p>Isn't that cute?</p>
<h3>Python Implementation</h3>
<p>Imagine we would prefer a less verbose approach. We can implement the
above using Python and the
<a href="https://redis-py.readthedocs.io/en/latest/">redis-py</a> package. The
package exposes a set of thin wrappers around the Redis API.</p>
<p>If we wanted to re-create the expiring priority set example we saw
above, we could use the following <code>redis-py</code> powered code:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExpiringSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ttl</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ttl</span> <span class="o">=</span> <span class="n">ttl</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Add an element with a given score&#39;&#39;&#39;</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">now</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">score</span> <span class="k">else</span> <span class="n">score</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">redis</span><span class="o">.</span><span class="n">pipeline</span><span class="p">()</span> <span class="k">as</span> <span class="n">pipe</span><span class="p">:</span>
            <span class="n">pipe</span><span class="o">.</span><span class="n">zremrangebyscore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttl</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                <span class="n">pipe</span><span class="o">.</span><span class="n">zremrangebyscore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>
            <span class="n">pipe</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pack</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">score</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all elements as a Python list&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redis</span><span class="o">.</span><span class="n">zremrangebyscore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttl</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_unpack</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">redis</span><span class="o">.</span><span class="n">zrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="o">...</span>
</pre></div>
</td></tr></table>

<p>This code is based on the <code>PriorityQueue</code> class in the wonderfully
written <a href="https://github.com/tnm/qr">qr</a> package. The code itself is
hardly rocket-science, but we will step through it regardless.</p>
<p>Consider the <code>push</code> method. It takes one required parameter, <code>value</code>,
and two optional parameters, <code>score</code> and <code>unique</code>. If no score is
given, the current time is used; element uniqueness is not enforced by
default.</p>
<p>First notice the use of the familiar <code>zremrangebyscore</code> method. As
before, we use this call to remove any expired elements.</p>
<p>Now, note the use of the <code>pipeline</code> method. It ensures that all calls
up to the <code>execute</code> method are executed atomically. That is, they will
be evaluated as a block before any further operations can proceed. This
prevents concurrent uses of the sorted set from interfering with each
other. This is especially important when enforcing uniqueness.</p>
<p>As an illustration, consider the following code:</p>
<div class="highlight"><pre><span></span><span class="c1"># Process one</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ExpiringSet</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s1">&#39;Hello,&#39;</span><span class="p">,</span> <span class="mi">1463879868</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Process two</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ExpiringSet</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s1">&#39;World!&#39;</span><span class="p">,</span> <span class="mi">1463879868</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<p>Note the identical timestamp, <code>1463879868</code>. If the code did not
enforce atomicity, there would be four possible results, two of which
are valid:</p>
<div class="highlight"><pre><span></span><span class="c1"># Result 1: Process one completes entirely first:</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;World!&#39;</span><span class="p">]</span>

<span class="c1"># Result 2: Process two completes entirely first:</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Hello,&#39;</span><span class="p">]</span>

<span class="c1"># Result 3 and 4: Process one and two intermix:</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Hello,&#39;</span><span class="p">,</span> <span class="s1">&#39;World!&#39;</span><span class="p">]</span> <span class="c1"># Or the reverse</span>
</pre></div>


<p>The reason for results 3 and 4 can be explained by considering the
following, non-pipelined code:</p>
<div class="highlight"><pre><span></span>if unique:
   redis.zremrangebyscore(self.key, score, score)
redis.zadd(self.key, self._pack(value), score)
</pre></div>


<p>In the event of both processes completing calls to
<code>zremrangebyscore</code>, there will be a race to call <code>zadd</code>. Regardless of
execution order of the processes, the result will be a set with two
elements, when only one is expected.</p>
<p>As a side note, the <code>_pack</code> method serializes the data; we do this to
ensure that non-trivial data, like a dictionary, can be unpacked
later. By default, this is done using <code>pickle</code>, but any serializer,
like a JSON serializer, can be used.</p>
<p>The <code>elements</code> method should be clear: it expires old elements and
returns all list of the remaining ones. Not the use of <code>_unpack</code>; it
reverts the serialization performed on insertion.</p>
<h2>Conclusion</h2>
<p>Well, that about wraps it up.</p>
<p>We covered two methods for implementing time expired sets. One used a
list of keys and the other used a sorted sets. We also implemented a
version of the sorted sets approach in Python, using the <code>redis-py</code>
package.</p>
<p>There is much more than can be done that is not covered in this
article; if you are interested in the code, you can view it here:
<a href="https://github.com/versionzero/qr">github.com/versionzero/qr</a>.</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://versionzero.org/tag/python.html">Python</a>
      <a href="http://versionzero.org/tag/redis.html">Redis</a>
      <a href="http://versionzero.org/tag/data-structures.html">Data Structures</a>
    </p>
  </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'versionzero';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</article>

    <footer>
        <p>&copy; Ben Burnett </p>
<p>Based on <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-57348140-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Time Expired Sets Using Redis",
  "headline": "Time Expired Sets Using Redis",
  "datePublished": "2016-05-21 05:00:00-06:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Ben Burnett",
    "url": "http://versionzero.org/author/ben-burnett.html"
  },
  "image": "{{ SITEURL }}/{{ THEME_STATIC_DIR }}/img/profile.png",
  "url": "http://versionzero.org/blog/2016/05/21/expiring-sets/index.html",
  "description": "Redis-driven sets expired by time."
}
</script></body>
</html>