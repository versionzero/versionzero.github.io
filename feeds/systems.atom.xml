<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>versionzero</title><link href="http://versionzero.org/" rel="alternate"></link><link href="http://versionzero.org/feeds/systems.atom.xml" rel="self"></link><id>http://versionzero.org/</id><updated>2016-04-09T12:00:00-06:00</updated><entry><title>Run Windows commands from the Windows Subsystem for Linux</title><link href="http://versionzero.org/blog/2016/04/09/run-windows-cmds-in-wsl/index.html" rel="alternate"></link><published>2016-04-09T12:00:00-06:00</published><author><name>Ben Burnett</name></author><id>tag:versionzero.org,2016-04-09:blog/2016/04/09/run-windows-cmds-in-wsl/index.html</id><summary type="html">&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;A while back, &lt;a href="http://www.microsoft.com/"&gt;Microsoft&lt;/a&gt; announced a
partnership with &lt;a href="http://www.canonical.com"&gt;Canonical&lt;/a&gt; that would
bring native &lt;a href="https://blogs.windows.com/windowsexperience/2016/04/06/announcing-windows-10-insider-preview-build-14316/"&gt;support for
Linux&lt;/a&gt;
to the Windows echo-system.&lt;/p&gt;
&lt;p&gt;The partnership includes creating an addition to Windows 10, through a
new subsystem called Windows Subsystem for Linux, that allows Windows
to run and use a subset of an Ubuntu distribution. A working version
of this system&amp;mdash;still in beta&amp;mdash;was release on April 6th 2016
and is available through the &lt;a href="https://blogs.windows.com/windowsexperience/2016/04/06/announcing-windows-10-insider-preview-build-14316/"&gt;Windows Insider
Program&lt;/a&gt;. You
can also watch the project activity on the &lt;a href="https://blogs.msdn.microsoft.com/commandline/"&gt;Windows Command Line Tools
For Developers&lt;/a&gt; blog.&lt;/p&gt;
&lt;p&gt;One of the problems with the Windows Subsystem for Linux (herein WSL)
is that it &lt;em&gt;only&lt;/em&gt; supports running Linux tasks. According to
Microsoft, "&lt;a href="https://blogs.windows.com/buildingapps/2016/03/30/run-bash-on-ubuntu-on-windows/"&gt;you cannot interact with Windows applications and
tools.&lt;/a&gt;"
That is to say, if you launch &lt;code&gt;bash&lt;/code&gt;, you cannot run, say,
&lt;code&gt;notepad.exe&lt;/code&gt; from &lt;em&gt;within&lt;/em&gt; &lt;code&gt;bash&lt;/code&gt;. This means that Windows system
tasks cannot be automated. This is unfortunate, since using the
assortment of Linux tools perform some of these tasks would be ideal.&lt;/p&gt;
&lt;p&gt;Systems like &lt;a href="https://cygwin.com"&gt;Cygwin&lt;/a&gt; (or more interestingly,
&lt;a href="http://babun.github.io"&gt;Babun&lt;/a&gt;) can inter-operate with Windows
application. However, this is due to the way the systems were
implemented. Cygwin, for instance, is a collection of Unix tool that
have been ported and compiled to run on Windows. This is stark
contrast to how WSL operates, which actually runs native Linux
applications.&lt;/p&gt;
&lt;p&gt;The purposes of this post is to demonstrate that it is possible to
escape the Linux sand-box and run native Windows applications.&lt;/p&gt;
&lt;h2&gt;The Approach&lt;/h2&gt;
&lt;p&gt;The way in which WSL works does not allow us to escape the Linux
sand-box directly. To do this we will require a set of tools
specifically crafted for this task.&lt;/p&gt;
&lt;p&gt;A simple tool, available
&lt;a href="https://github.com/versionzero/winrun"&gt;here&lt;/a&gt;, allows Linux
applications to interact with Windows. It operates by monitoring the
Windows filesystem for changes. If a new file is detected, it is read
and the command it contains is run.&lt;/p&gt;
&lt;p&gt;Consider the case of &lt;code&gt;notepad.exe&lt;/code&gt;. If we would like to launch it, we
need only create a new file, containing the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;C:/Windows/notepad.exe
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that we use &lt;code&gt;/&lt;/code&gt; slashes. This is to avoid having to deal with
double escaping the path, using &lt;code&gt;\\\\&lt;/code&gt; as a delimiter.&lt;/p&gt;
&lt;p&gt;Our utility will notice the creation of a new file and starts the
process churning.&lt;/p&gt;
&lt;p&gt;Communicating the application name to the WSL is now simply a matter
of creating a new text file with the command we care to run. There are
many ways to do this in Linux, but a simple one takes the following
form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;C:/Windows/notepad.exe&amp;quot;&lt;/span&gt; &amp;gt; /mnt/c/winrun/run
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Where &lt;code&gt;run&lt;/code&gt; is an arbitrary name of a text file, and &lt;code&gt;/mnt/c/winrun&lt;/code&gt;
is a directory that can be read and written to by both Windows and
Linux.&lt;/p&gt;
&lt;p&gt;Note that the current implementation of the monitoring tool will not
delete the &lt;code&gt;run&lt;/code&gt; file, so we need to clean it up ourselves.&lt;/p&gt;
&lt;h2&gt;How it Works&lt;/h2&gt;
&lt;p&gt;The monitoring tools is a plain vanilla Win32 application. When run,
it opens &lt;code&gt;C:\winrun&lt;/code&gt; and monitors the directory for the creation of
new files.&lt;/p&gt;
&lt;p&gt;The processes by which it accomplishes this is a somewhat complex, but
that is generally the nature of Win32 programming.&lt;/p&gt;
&lt;p&gt;First, we use the
&lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365465(v=vs.85).aspx"&gt;&lt;code&gt;ReadDirectoryChangesW&lt;/code&gt;&lt;/a&gt;
API call to detect any change in the directory we are monitoring. When
a file is added,&lt;/p&gt;
&lt;p&gt;If you have any questions or comments for me, please leave them bellow.&lt;/p&gt;</summary><category term="Windows"></category><category term="Linux"></category></entry></feed>